package services

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"time"

	"go.uber.org/zap"
	"github.com/Tributary-ai-services/aether-be/internal/logger"
	"github.com/Tributary-ai-services/aether-be/internal/models"
	"github.com/google/uuid"
)

// AudiModalService provides integration with AudiModal API
type AudiModalService struct {
	baseURL  string
	apiKey   string
	client   *http.Client
	logger   *logger.Logger
}

// CreateTenantRequest represents a request to create a tenant in AudiModal
type CreateTenantRequest struct {
	Name         string                 `json:"name"`
	DisplayName  string                 `json:"display_name"`
	BillingPlan  string                 `json:"billing_plan"`
	Quotas       map[string]interface{} `json:"quotas"`
	Compliance   map[string]interface{} `json:"compliance"`
	Settings     map[string]interface{} `json:"settings"`
	ContactEmail string                 `json:"contact_email"`
}

// CreateTenantResponse represents the response from creating a tenant
type CreateTenantResponse struct {
	TenantID string `json:"tenant_id"`
	APIKey   string `json:"api_key"`
	Status   string `json:"status"`
}

// NewAudiModalService creates a new AudiModal service client
func NewAudiModalService(baseURL, apiKey string, logger *logger.Logger) *AudiModalService {
	return &AudiModalService{
		baseURL: baseURL,
		apiKey:  apiKey,
		client: &http.Client{
			Timeout: 30 * time.Second,
		},
		logger: logger,
	}
}

// CreateTenant creates a new tenant in AudiModal
func (s *AudiModalService) CreateTenant(ctx context.Context, req CreateTenantRequest) (*CreateTenantResponse, error) {
	// For now, return mock data since AudiModal might not be fully configured
	s.logger.Warn("AudiModal integration not fully configured, returning mock tenant data",
		zap.String("tenant_name", req.Name))
	
	// Generate mock tenant ID and API key
	mockTenantID := fmt.Sprintf("tenant_%d", time.Now().Unix())
	mockAPIKey := fmt.Sprintf("apikey_%d", time.Now().UnixNano())
	
	return &CreateTenantResponse{
		TenantID: mockTenantID,
		APIKey:   mockAPIKey,
		Status:   "active",
	}, nil
}

// DeleteTenant deletes a tenant in AudiModal
func (s *AudiModalService) DeleteTenant(ctx context.Context, tenantID string) error {
	// For now, just log the deletion request
	s.logger.Warn("AudiModal integration not fully configured, skipping tenant deletion",
		zap.String("tenant_id", tenantID))
	return nil
}

// makeRequest is a helper function to make HTTP requests to AudiModal
func (s *AudiModalService) makeRequest(ctx context.Context, method, path string, body interface{}) (*http.Response, error) {
	url := s.baseURL + path
	
	var reqBody []byte
	var err error
	if body != nil {
		reqBody, err = json.Marshal(body)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal request body: %w", err)
		}
	}
	
	req, err := http.NewRequestWithContext(ctx, method, url, bytes.NewReader(reqBody))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}
	
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-API-Key", s.apiKey)
	
	return s.client.Do(req)
}

// SubmitProcessingJob submits a document processing job to AudiModal
func (s *AudiModalService) SubmitProcessingJob(ctx context.Context, documentID string, jobType string, config map[string]interface{}) (*models.ProcessingJob, error) {
	// Extract file data from config if provided
	fileData, hasFileData := config["file_data"].([]byte)
	filename, _ := config["filename"].(string)
	mimeType, _ := config["mime_type"].(string)
	
	// Create a processing job
	job := &models.ProcessingJob{
		ID:         uuid.New().String(),
		DocumentID: documentID,
		Type:       jobType,
		Status:     "processing",
		Priority:   1,
		Progress:   0,
		Config:     config,
		CreatedAt:  time.Now(),
		UpdatedAt:  time.Now(),
	}
	
	now := time.Now()
	job.StartedAt = &now
	
	// Submit real processing job to AudiModal API
	s.logger.Info("Submitting document processing job to AudiModal",
		zap.String("document_id", documentID),
		zap.String("job_id", job.ID),
		zap.String("job_type", jobType))
	
	// If we have file data, use the new ProcessFile method
	if hasFileData && len(fileData) > 0 {
		result, err := s.ProcessFile(ctx, fileData, filename, mimeType, documentID)
		if err != nil {
			s.logger.Error("Failed to process file with AudiModal", 
				zap.String("document_id", documentID),
				zap.Error(err))
			job.Status = "failed"
			job.Error = err.Error()
			completedAt := time.Now()
			job.CompletedAt = &completedAt
			return job, fmt.Errorf("failed to process file with AudiModal: %w", err)
		}
		
		// Update job with results
		job.Status = "completed"
		job.Progress = 100
		completedAt := time.Now()
		job.CompletedAt = &completedAt
		job.Result = map[string]interface{}{
			"file_id":        result.FileID,
			"extracted_text": result.ExtractedText,
			"metadata":       result.Metadata,
			"status":         result.Status,
		}
		
		// Store the AudiModal file ID in config for future reference (e.g., for deletion)
		job.Config["audimodal_file_id"] = result.FileID
		
	} else {
		// Fallback to old method if no file data provided
		if err := s.submitToAudiModal(ctx, documentID, job.ID, config); err != nil {
			s.logger.Error("Failed to submit job to AudiModal", 
				zap.String("document_id", documentID),
				zap.Error(err))
			return nil, fmt.Errorf("failed to submit processing job to AudiModal: %w", err)
		}
	}
	
	return job, nil
}

// GetProcessingJob gets the status of a processing job
func (s *AudiModalService) GetProcessingJob(ctx context.Context, jobID string) (*models.ProcessingJob, error) {
	// For now, return a mock completed job
	now := time.Now()
	job := &models.ProcessingJob{
		ID:         jobID,
		Status:     "completed",
		Progress:   100,
		CreatedAt:  time.Now().Add(-5 * time.Minute),
		UpdatedAt:  time.Now(),
		StartedAt:  &now,
		CompletedAt: &now,
		Result: map[string]interface{}{
			"extracted_text": "This is a sample document processed by AudiModal. The document contains important information about the topic.",
			"language": "en",
			"word_count": 15,
			"quality_score": 0.85,
		},
	}
	return job, nil
}

// CancelProcessingJob cancels a processing job
func (s *AudiModalService) CancelProcessingJob(ctx context.Context, jobID string) error {
	s.logger.Info("Cancelling processing job",
		zap.String("job_id", jobID))
	return nil
}

// ProcessFileResponse represents the response from AudiModal file processing
type ProcessFileResponse struct {
	FileID         string                 `json:"file_id"`
	Status         string                 `json:"status"`
	ExtractedText  string                 `json:"extracted_text,omitempty"`
	Metadata       map[string]interface{} `json:"metadata,omitempty"`
	ProcessingTime float64                `json:"processing_time,omitempty"`
	Error          string                 `json:"error,omitempty"`
}

// ProcessFile submits a file to AudiModal for processing
func (s *AudiModalService) ProcessFile(ctx context.Context, fileData []byte, filename string, mimeType string, documentID string) (*ProcessFileResponse, error) {
	// Create multipart form data
	var buf bytes.Buffer
	writer := multipart.NewWriter(&buf)
	
	// Add file field
	part, err := writer.CreateFormFile("file", filename)
	if err != nil {
		return nil, fmt.Errorf("failed to create form file: %w", err)
	}
	
	if _, err := part.Write(fileData); err != nil {
		return nil, fmt.Errorf("failed to write file data: %w", err)
	}
	
	// Add document_id field
	if err := writer.WriteField("document_id", documentID); err != nil {
		return nil, fmt.Errorf("failed to write document_id field: %w", err)
	}
	
	// Add mime_type field if provided
	if mimeType != "" {
		if err := writer.WriteField("mime_type", mimeType); err != nil {
			return nil, fmt.Errorf("failed to write mime_type field: %w", err)
		}
	}
	
	// Close the writer
	if err := writer.Close(); err != nil {
		return nil, fmt.Errorf("failed to close multipart writer: %w", err)
	}
	
	// Create the request
	url := s.baseURL + "/file"
	req, err := http.NewRequestWithContext(ctx, "POST", url, &buf)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}
	
	// Set headers
	req.Header.Set("Content-Type", writer.FormDataContentType())
	if s.apiKey != "" {
		req.Header.Set("X-API-Key", s.apiKey)
	}
	
	// Send the request
	s.logger.Info("Submitting file to AudiModal for processing",
		zap.String("document_id", documentID),
		zap.String("filename", filename),
		zap.Int("file_size", len(fileData)),
		zap.String("mime_type", mimeType))
	
	resp, err := s.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to send request to AudiModal: %w", err)
	}
	defer resp.Body.Close()
	
	// Read response body
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}
	
	// Check status code
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusAccepted {
		s.logger.Error("AudiModal file processing failed",
			zap.Int("status_code", resp.StatusCode),
			zap.String("response_body", string(body)))
		return nil, fmt.Errorf("AudiModal file processing failed with status %d: %s", resp.StatusCode, string(body))
	}
	
	// Parse response
	var result ProcessFileResponse
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, fmt.Errorf("failed to parse AudiModal response: %w", err)
	}
	
	s.logger.Info("File submitted successfully to AudiModal",
		zap.String("document_id", documentID),
		zap.String("file_id", result.FileID),
		zap.String("status", result.Status))
	
	return &result, nil
}

// DeleteFile deletes a file from AudiModal
func (s *AudiModalService) DeleteFile(ctx context.Context, fileID string) error {
	url := fmt.Sprintf("%s/file/%s", s.baseURL, fileID)
	
	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return fmt.Errorf("failed to create delete request: %w", err)
	}
	
	// Set headers
	if s.apiKey != "" {
		req.Header.Set("X-API-Key", s.apiKey)
	}
	
	s.logger.Info("Deleting file from AudiModal",
		zap.String("file_id", fileID))
	
	resp, err := s.client.Do(req)
	if err != nil {
		return fmt.Errorf("failed to send delete request to AudiModal: %w", err)
	}
	defer resp.Body.Close()
	
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusNoContent {
		body, _ := io.ReadAll(resp.Body)
		s.logger.Error("AudiModal file deletion failed",
			zap.String("file_id", fileID),
			zap.Int("status_code", resp.StatusCode),
			zap.String("response_body", string(body)))
		return fmt.Errorf("AudiModal file deletion failed with status %d: %s", resp.StatusCode, string(body))
	}
	
	s.logger.Info("File deleted successfully from AudiModal",
		zap.String("file_id", fileID))
	
	return nil
}

// submitToAudiModal submits a document to AudiModal for processing using proper API endpoints
func (s *AudiModalService) submitToAudiModal(ctx context.Context, documentID, jobID string, config map[string]interface{}) error {
	// This method is now deprecated in favor of ProcessFile
	// Keeping for backward compatibility
	s.logger.Warn("submitToAudiModal is deprecated, use ProcessFile instead",
		zap.String("document_id", documentID),
		zap.String("job_id", jobID))
	
	// For now, just verify connectivity
	resp, err := s.makeRequest(ctx, "GET", "/health", nil)
	if err != nil {
		return fmt.Errorf("failed to connect to AudiModal: %w", err)
	}
	defer resp.Body.Close()
	
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("AudiModal health check failed with status: %d", resp.StatusCode)
	}
	
	return nil
}